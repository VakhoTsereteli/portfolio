{"ast":null,"code":"import tinycolor from 'tinycolor2';\nfunction _colorChange(data, oldHue) {\n  var alpha = data && data.a;\n  var color;\n\n  // hsl is better than hex between conversions\n  if (data && data.hsl) {\n    color = tinycolor(data.hsl);\n  } else if (data && data.hex && data.hex.length > 0) {\n    color = tinycolor(data.hex);\n  } else if (data && data.hsv) {\n    color = tinycolor(data.hsv);\n  } else if (data && data.rgba) {\n    color = tinycolor(data.rgba);\n  } else if (data && data.rgb) {\n    color = tinycolor(data.rgb);\n  } else {\n    color = tinycolor(data);\n  }\n  if (color && (color._a === undefined || color._a === null)) {\n    color.setAlpha(alpha || 1);\n  }\n  var hsl = color.toHsl();\n  var hsv = color.toHsv();\n  if (hsl.s === 0) {\n    hsv.h = hsl.h = data.h || data.hsl && data.hsl.h || oldHue || 0;\n  }\n\n  /* --- comment this block to fix #109, may cause #25 again --- */\n  // when the hsv.v is less than 0.0164 (base on test)\n  // because of possible loss of precision\n  // the result of hue and saturation would be miscalculated\n  // if (hsv.v < 0.0164) {\n  //   hsv.h = data.h || (data.hsv && data.hsv.h) || 0\n  //   hsv.s = data.s || (data.hsv && data.hsv.s) || 0\n  // }\n\n  // if (hsl.l < 0.01) {\n  //   hsl.h = data.h || (data.hsl && data.hsl.h) || 0\n  //   hsl.s = data.s || (data.hsl && data.hsl.s) || 0\n  // }\n  /* ------ */\n\n  return {\n    hsl: hsl,\n    hex: color.toHexString().toUpperCase(),\n    hex8: color.toHex8String().toUpperCase(),\n    rgba: color.toRgb(),\n    hsv: hsv,\n    oldHue: data.h || oldHue || hsl.h,\n    source: data.source,\n    a: data.a || color.getAlpha()\n  };\n}\nexport default {\n  props: ['value'],\n  data() {\n    return {\n      val: _colorChange(this.value)\n    };\n  },\n  computed: {\n    colors: {\n      get() {\n        return this.val;\n      },\n      set(newVal) {\n        this.val = newVal;\n        this.$emit('input', newVal);\n      }\n    }\n  },\n  watch: {\n    value(newVal) {\n      this.val = _colorChange(newVal);\n    }\n  },\n  methods: {\n    colorChange(data, oldHue) {\n      this.oldHue = this.colors.hsl.h;\n      this.colors = _colorChange(data, oldHue || this.oldHue);\n    },\n    isValidHex(hex) {\n      return tinycolor(hex).isValid();\n    },\n    simpleCheckForValidColor(data) {\n      var keysToCheck = ['r', 'g', 'b', 'a', 'h', 's', 'l', 'v'];\n      var checked = 0;\n      var passed = 0;\n      for (var i = 0; i < keysToCheck.length; i++) {\n        var letter = keysToCheck[i];\n        if (data[letter]) {\n          checked++;\n          if (!isNaN(data[letter])) {\n            passed++;\n          }\n        }\n      }\n      if (checked === passed) {\n        return data;\n      }\n    },\n    paletteUpperCase(palette) {\n      return palette.map(c => c.toUpperCase());\n    },\n    isTransparent(color) {\n      return tinycolor(color).getAlpha() === 0;\n    }\n  }\n};","map":{"version":3,"names":["tinycolor","_colorChange","data","oldHue","alpha","a","color","hsl","hex","length","hsv","rgba","rgb","_a","undefined","setAlpha","toHsl","toHsv","s","h","toHexString","toUpperCase","hex8","toHex8String","toRgb","source","getAlpha","props","val","value","computed","colors","get","set","newVal","$emit","watch","methods","colorChange","isValidHex","isValid","simpleCheckForValidColor","keysToCheck","checked","passed","i","letter","isNaN","paletteUpperCase","palette","map","c","isTransparent"],"sources":["/home/vakho_tsereteli/portfolio/node_modules/vue-color/src/mixin/color.js"],"sourcesContent":["import tinycolor from 'tinycolor2'\n\nfunction _colorChange (data, oldHue) {\n  var alpha = data && data.a\n  var color\n\n  // hsl is better than hex between conversions\n  if (data && data.hsl) {\n    color = tinycolor(data.hsl)\n  } else if (data && data.hex && data.hex.length > 0) {\n    color = tinycolor(data.hex)\n  } else if (data && data.hsv) {\n    color = tinycolor(data.hsv)\n  } else if (data && data.rgba) {\n    color = tinycolor(data.rgba)\n  } else if (data && data.rgb) {\n    color = tinycolor(data.rgb)\n  } else {\n    color = tinycolor(data)\n  }\n\n  if (color && (color._a === undefined || color._a === null)) {\n    color.setAlpha(alpha || 1)\n  }\n\n  var hsl = color.toHsl()\n  var hsv = color.toHsv()\n\n  if (hsl.s === 0) {\n    hsv.h = hsl.h = data.h || (data.hsl && data.hsl.h) || oldHue || 0\n  }\n\n  /* --- comment this block to fix #109, may cause #25 again --- */\n  // when the hsv.v is less than 0.0164 (base on test)\n  // because of possible loss of precision\n  // the result of hue and saturation would be miscalculated\n  // if (hsv.v < 0.0164) {\n  //   hsv.h = data.h || (data.hsv && data.hsv.h) || 0\n  //   hsv.s = data.s || (data.hsv && data.hsv.s) || 0\n  // }\n\n  // if (hsl.l < 0.01) {\n  //   hsl.h = data.h || (data.hsl && data.hsl.h) || 0\n  //   hsl.s = data.s || (data.hsl && data.hsl.s) || 0\n  // }\n  /* ------ */\n\n  return {\n    hsl: hsl,\n    hex: color.toHexString().toUpperCase(),\n    hex8: color.toHex8String().toUpperCase(),\n    rgba: color.toRgb(),\n    hsv: hsv,\n    oldHue: data.h || oldHue || hsl.h,\n    source: data.source,\n    a: data.a || color.getAlpha()\n  }\n}\n\nexport default {\n  props: ['value'],\n  data () {\n    return {\n      val: _colorChange(this.value)\n    }\n  },\n  computed: {\n    colors: {\n      get () {\n        return this.val\n      },\n      set (newVal) {\n        this.val = newVal\n        this.$emit('input', newVal)\n      }\n    }\n  },\n  watch: {\n    value (newVal) {\n      this.val = _colorChange(newVal)\n    }\n  },\n  methods: {\n    colorChange (data, oldHue) {\n      this.oldHue = this.colors.hsl.h\n      this.colors = _colorChange(data, oldHue || this.oldHue)\n    },\n    isValidHex (hex) {\n      return tinycolor(hex).isValid()\n    },\n    simpleCheckForValidColor (data) {\n      var keysToCheck = ['r', 'g', 'b', 'a', 'h', 's', 'l', 'v']\n      var checked = 0\n      var passed = 0\n\n      for (var i = 0; i < keysToCheck.length; i++) {\n        var letter = keysToCheck[i]\n        if (data[letter]) {\n          checked++\n          if (!isNaN(data[letter])) {\n            passed++\n          }\n        }\n      }\n\n      if (checked === passed) {\n        return data\n      }\n    },\n    paletteUpperCase (palette) {\n      return palette.map(c => c.toUpperCase())\n    },\n    isTransparent (color) {\n      return tinycolor(color).getAlpha() === 0\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}